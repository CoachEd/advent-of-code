package twenty;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import utils.Dijkstra;
import utils.Edge1;
import utils.Vertex;

public class part0_3 {

	public static int width = 13;
	public static int height = 13;
	public static int startx = 7;
	public static int starty = 7;
	public static char[][] themap = new char[height][width];
	public static char UNKNOWN = '?';
	public static char ROOM = '.';
	public static char WALL = '#';
	public static char HDOOR = '|';
	public static char VDOOR = '-';
	public static int currx, curry;

	public static void main(String[] args) {

		for (int row=0; row < themap.length; row++) {
			for (int col=0; col < themap[row].length; col++) {
				themap[row][col] = '?';
			}
		}


		//combinations generated by: python exrex.py 'ENWWW(NEEE|SSE(EE|N))' 
		//clone: git@github.com:asciimoo/exrex.git
		ArrayList<String> al = new ArrayList<String>();
		al.add("ESSWWNE");
		al.add("ESSWWNNNENNEESSWNSESSS");
		al.add("ESSWWNNNENNEESSSSS");
		al.add("ESSWWNNNENNWWWSSSSESW");
		al.add("ESSWWNNNENNWWWSSSSENNNE");
		for (String s : al) {
			//start position
			currx = startx;
			curry = starty;
			themap[curry][currx] = ROOM;
			parseliteral(s,currx,curry);
		}

		printRoom();


		//now find the room for which the shortest path to that room 
		//would require passing through the most doors

		//create the graph
		HashMap<String,Vertex> vertices = new HashMap<String,Vertex>();
		String sid;
		for (int row=0; row < themap.length; row++) {
			for (int col=0; col < themap[row].length; col++) {
				sid = col + "|" + row;
				if (themap[row][col] == ROOM) {
					if (!vertices.containsKey(sid)) {
						vertices.put(sid, new Vertex(sid));
					}
				}
			}
		}

		//for each node, add its edges
		HashMap<String,Edge1> edges = new HashMap<String,Edge1>();
		String toid = "";
		for (int row=0; row < themap.length; row++) {
			for (int col=0; col < themap[row].length; col++) {
				if (themap[row][col] != ROOM) continue;
				sid = col + "|" + row;

				Vertex v = vertices.get(sid);
				Vertex v2;
				String edgeid = "";
				Edge1 edge;
				//up node?
				if (themap[row-1][col] == VDOOR) {
					toid = col + "|" + (row-2);
					v2 = vertices.get(toid);
					edgeid = v.name + "|" + v2.name;
					if (!edges.containsKey(edgeid)) {
						edge = new Edge1(v2, 1);
						edges.put(edgeid, edge);
						v.adjacencies.add(edge);
					}
				}

				//down node?
				if (themap[row+1][col] == VDOOR) {
					toid = col + "|" + (row+2);
					v2 = vertices.get(toid);
					edgeid = v.name + "|" + v2.name;
					if (!edges.containsKey(edgeid)) {
						edge = new Edge1(v2, 1);
						edges.put(edgeid, edge);
						v.adjacencies.add(edge);
					}
				}

				//right node?
				if (themap[row][col+1] == HDOOR) {
					toid = (col+2) + "|" + row;
					v2 = vertices.get(toid);
					edgeid = v.name + "|" + v2.name;
					if (!edges.containsKey(edgeid)) {
						edge = new Edge1(v2, 1);
						edges.put(edgeid, edge);
						v.adjacencies.add(edge);
					}
				}

				//left node?
				if (themap[row][col-1] == HDOOR) {
					toid = (col-2) + "|" + row;
					v2 = vertices.get(toid);
					edgeid = v.name + "|" + v2.name;
					if (!edges.containsKey(edgeid)) {
						edge = new Edge1(v2, 1);
						edges.put(edgeid, edge);
						v.adjacencies.add(edge);
					}
				}

			}
		}

		sid = startx +"|" + starty;
		Vertex vstart = vertices.get(sid); //start vertex
		Dijkstra.computePaths(vstart); // run Dijkstra

		int largest_path = Integer.MIN_VALUE;
		for (Map.Entry<String, Vertex> entry : vertices.entrySet()) {
			Vertex v = entry.getValue();
			List<Vertex> path = Dijkstra.getShortestPathTo(v); //no path is list of size 1 (itself)
			//System.out.println("Path from,to  " + vstart.name + "," + v.name +"  " + path + "   path.size(): " + path.size());
			if (path.size() > largest_path)
				largest_path = path.size();
			System.out.println("path.size(): " + path.size());
		}
		System.out.println("\nLargest number of doors required to pass through to reach a room?: " + (largest_path-1) + " rooms.");






	}

	public static void parseliteral(String s, int currx, int curry) {
		if (s == null || s.length() == 0)
			return;
		for (int i=0; i < s.length(); i++) {
			char c = s.charAt(i);
			switch(c) {
			case 'N':
				curry--;
				themap[curry][currx] = VDOOR;
				themap[curry][currx-1] = WALL;
				themap[curry][currx+1] = WALL;
				curry--;
				themap[curry][currx] = ROOM;
				themap[curry-1][currx-1] = WALL;
				themap[curry-1][currx+1] = WALL;				
				break;
			case 'S':
				curry++;
				themap[curry][currx] = VDOOR;
				themap[curry][currx-1] = WALL;
				themap[curry][currx+1] = WALL;
				curry++;
				themap[curry][currx] = ROOM;
				themap[curry+1][currx-1] = WALL;
				themap[curry+1][currx+1] = WALL;	
				break;
			case 'E':
				currx++;
				themap[curry][currx] = HDOOR;
				themap[curry-1][currx] = WALL;
				themap[curry+1][currx] = WALL;
				currx++;
				themap[curry][currx] = ROOM;
				themap[curry-1][currx+1] = WALL;
				themap[curry+1][currx+1] = WALL;
				break;
			case 'W':
				currx--;
				themap[curry][currx] = HDOOR;
				themap[curry-1][currx] = WALL;
				themap[curry+1][currx] = WALL;
				currx--;
				themap[curry][currx] = ROOM;
				themap[curry-1][currx-1] = WALL;
				themap[curry+1][currx-1] = WALL;	
				break;
			default:
				System.out.println("SHOULD NOT HAPPEN: " + c);
				break;
			}
		}
		return;
	}

	public static void printRoom() {
		String s = "";
		for (int row=0; row < themap.length; row++) {
			for (int col=0; col < themap[row].length; col++) {
				if (themap[row][col] == UNKNOWN)
					themap[row][col] = WALL;
				s += themap[row][col];
			}
			s+="\n";
		}
		System.out.println(s);
	}

}
